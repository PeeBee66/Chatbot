Date: 2024-09-17 12:50:29

ai_handler.py:
import logging
import csv
from ollama_handler import handle_ollama_response

class AIHandler:
    def __init__(self, ollama_api, background_prompt):
        self.ollama_api = ollama_api
        self.background_prompt = background_prompt

    def process_new_message(self, log_file, username, message, chat_input_position):
        # Get all messages from the CSV
        with open(log_file, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.reader(file)
            next(reader)  # Skip header
            all_messages = list(reader)

        # Construct the conversation history
        conversation_history = [f"{row[2]}: {row[3]}" for row in all_messages]
        
        # Construct the system prompt
        system_prompt = f"{self.background_prompt}\n\nCurrent chat:\n" + "\n".join(conversation_history)

        # Get the last messages from the triggering user
        user_messages = [msg for msg in reversed(all_messages) if msg[2] == username]
        last_user_conversation = "\n".join([f"{msg[2]}: {msg[3]}" for msg in user_messages])

        # Use the OllamaResponseHandler
        response, error = handle_ollama_response(
            None,  # We don't need the parent widget here
            self.ollama_api,
            system_prompt,
            f"Please respond to the following conversation from {username}:",
            last_user_conversation,
            chat_input_position
        )

        if error:
            logging.error(f"Error in Ollama response: {error}")
            return None, error
        else:
            logging.info(f"Ollama's response: {response}")
            return response, None

    def set_background_prompt(self, prompt):
        self.background_prompt = prompt

analysis.py:
from PyQt5.QtCore import QThread, pyqtSignal
from ollama import OllamaAPI
import csv
import logging

class AnalysisThread(QThread):
    analysis_complete = pyqtSignal(str)

    def __init__(self, log_file, background_prompt, ollama_api):
        super().__init__()
        self.log_file = log_file
        self.background_prompt = background_prompt
        self.ollama_api = ollama_api

    def run(self):
        response = self.start_conversation()
        self.analysis_complete.emit(response)

    def start_conversation(self):
        try:
            with open(self.log_file, mode='r', newline='', encoding='utf-8') as file:
                reader = csv.reader(file)
                next(reader)  # Skip header
                chat_history = [f"{row[1]}: {row[2]}" for row in reader]
            
            chat_history_text = "\n".join(chat_history)
            prompt = f"{self.background_prompt}\n\n{chat_history_text}"
            logging.info("Contacting Ollama server: Please wait for response (this may take a bit depending on AI assistant speeds)")
            response = self.ollama_api.send_request(self.background_prompt, "Please respond to the following conversation.", chat_history_text)
            logging.info("Received response from Ollama server")
            
            return response
        except Exception as e:
            logging.error(f"Error starting conversation: {str(e)}")
            return ""

def process_new_message(message, background_prompt, ollama_api):
    try:
        logging.info("Contacting Ollama server: Please wait for response (this may take a bit depending on AI assistant speeds)")
        response = ollama_api.send_request(background_prompt, 
                                           "Please respond to the following message:", 
                                           message)
        logging.info("Received response from Ollama server")
        return response
    except Exception as e:
        logging.error(f"Error processing new message: {str(e)}")
        return ""

def get_chat_history(log_file):
    try:
        with open(log_file, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.reader(file)
            next(reader)  # Skip header
            return [f"{row[1]}: {row[2]}" for row in reader]
    except Exception as e:
        logging.error(f"Error reading chat history: {str(e)}")
        return []

def analyze_conversation(chat_history, background_prompt, ollama_api):
    chat_history_text = "\n".join(chat_history)
    prompt = f"{background_prompt}\n\n{chat_history_text}"
    try:
        response = ollama_api.send_request(background_prompt, 
                                           "Please analyze the following conversation:", 
                                           chat_history_text)
        return response
    except Exception as e:
        logging.error(f"Error analyzing conversation: {str(e)}")
        return ""

analyzer.py:
import logging
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QSizeGrip
from PyQt5.QtCore import Qt, pyqtSignal, QSize
from PyQt5.QtGui import QPainter, QColor, QPen
import pytesseract
from PIL import ImageGrab, Image

logging.basicConfig(filename='chat_analyzer_log.txt', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

class TransparentWindow(QWidget):
    text_captured = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.min_size = QSize(300, 100)  # Increased minimum size
        self.initUI()
        self.oldPos = None
        pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'
        logging.info(f"Tesseract path set to: {pytesseract.pytesseract.tesseract_cmd}")

    def initUI(self):
        self.setWindowTitle('Chat Analyzer')
        self.setGeometry(100, 100, 400, 300)
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setMinimumSize(self.min_size)

        layout = QVBoxLayout()
        self.setLayout(layout)

        size_grip = QSizeGrip(self)
        layout.addWidget(size_grip, 0, Qt.AlignBottom | Qt.AlignRight)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setBrush(QColor(0, 0, 0, 50))
        painter.setPen(Qt.NoPen)
        painter.drawRect(self.rect())
        painter.setPen(QPen(QColor(255, 255, 255), 2, Qt.SolidLine))
        painter.drawRect(self.rect().adjusted(1, 1, -1, -1))

    def mousePressEvent(self, event):
        self.oldPos = event.globalPos()

    def mouseMoveEvent(self, event):
        if self.oldPos:
            delta = event.globalPos() - self.oldPos
            new_pos = self.pos() + delta
            self.move(new_pos)
            self.oldPos = event.globalPos()

    def mouseReleaseEvent(self, event):
        self.oldPos = None

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if self.width() < self.min_size.width() or self.height() < self.min_size.height():
            self.setGeometry(self.x(), self.y(), max(self.width(), self.min_size.width()), max(self.height(), self.min_size.height()))
            logging.warning(f"Window resized to minimum size: {self.size()}")

    def capture_screen(self):
        try:
            logging.debug("Attempting to capture screen")
            x, y, w, h = self.geometry().getRect()
            logging.info(f"Capture size: {w}x{h}")  # Log capture size
            
            screenshot = ImageGrab.grab(bbox=(x, y, x + w, y + h))
            screenshot = screenshot.resize((w * 2, h * 2), Image.LANCZOS)
            
            screenshot.save("debug_screenshot.png")
            logging.debug(f"Screenshot saved: debug_screenshot.png")

            # Improve OCR accuracy
            text = pytesseract.image_to_string(screenshot, config='--psm 6 --oem 3')
            logging.debug(f"Captured text length: {len(text)}")
            if not text:
                logging.warning("No text captured by Tesseract")
            else:
                logging.debug(f"Captured text: {text[:100]}...")  # Log first 100 characters
            return text
        except Exception as e:
            logging.error(f"Error capturing screen: {str(e)}")
            return ""

backup_py.py:
import os
from datetime import datetime

def backup_py_files():
    # Get the current date and time
    current_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Create/open the backup text file
    with open("backup_py.txt", "w") as backup_file:
        # Write the current date at the top
        backup_file.write(f"Date: {current_date}\n\n")
        
        # Iterate over all files in the current directory
        for filename in os.listdir('.'):
            # Check if the file is a Python file
            if filename.endswith(".py"):
                # Write the filename
                backup_file.write(f"{filename}:\n")
                
                # Open and write the contents of the Python file
                with open(filename, "r") as py_file:
                    code = py_file.read()
                    backup_file.write(code)
                    backup_file.write("\n\n")  # Add some spacing between files

    print("Backup complete! All Python files have been saved to backup_py.txt.")

# Run the function to create the backup
backup_py_files()


capture.py:
from PyQt5.QtCore import QThread, pyqtSignal
from utils import process_captured_text
import logging

class CaptureThread(QThread):
    capture_complete = pyqtSignal(list)

    def __init__(self, analyzer_window, my_username, other_usernames, ignored_patterns):
        super().__init__()
        self.analyzer_window = analyzer_window
        self.my_username = my_username
        self.other_usernames = other_usernames
        self.ignored_patterns = ignored_patterns

    def run(self):
        logging.debug("CaptureThread started")
        text = self.analyzer_window.capture_screen()
        logging.debug(f"Raw captured text: {text[:100]}...")  # Log first 100 characters
        processed_lines = process_captured_text(text, self.my_username, self.other_usernames, self.ignored_patterns)
        logging.debug(f"Processed lines: {processed_lines}")
        self.capture_complete.emit(processed_lines)

capture_handler.py:
import logging
import csv
from PyQt5.QtCore import QObject, pyqtSignal, pyqtSlot
from capture import CaptureThread
from utils import append_to_csv

class CaptureHandler(QObject):
    capture_complete = pyqtSignal(list)
    new_message_detected = pyqtSignal(str, str)

    def __init__(self, analyzer_window, my_username, other_usernames, ignored_patterns):
        super().__init__()
        self.analyzer_window = analyzer_window
        self.my_username = my_username
        self.other_usernames = other_usernames
        self.ignored_patterns = ignored_patterns
        self.log_file = None

    def start_capture(self):
        logging.info("System: Capture initiated")
        self.capture_thread = CaptureThread(self.analyzer_window, self.my_username, self.other_usernames, self.ignored_patterns)
        self.capture_thread.capture_complete.connect(self.on_capture_complete)
        self.capture_thread.start()

    @pyqtSlot(list)
    def on_capture_complete(self, processed_lines):
        logging.debug(f"Received processed lines: {processed_lines}")
        if processed_lines:
            for username, message in processed_lines:
                append_to_csv(self.log_file, "first_conversation", username, message)
            logging.info(f"Text added to chat log. Last line: {processed_lines[-1][1]}")
        else:
            logging.warning("No processed lines received")
        
        self.capture_complete.emit(processed_lines)

    def check_for_new_messages(self, processed_lines):
        new_messages = self.get_new_messages(processed_lines)
        if new_messages:
            for username, message in new_messages:
                logging.info(f"New user message detected: {username}: {message}")
                append_to_csv(self.log_file, "user_message", username, message)
                
                if username in self.other_usernames:
                    self.new_message_detected.emit(username, message)
            
            return new_messages[-1][1]  # Return the last captured line
        else:
            logging.info("No new user messages detected.")
            return None

    def get_new_messages(self, processed_lines):
        existing_messages = set()
        with open(self.log_file, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.reader(file)
            next(reader)  # Skip header
            for row in reader:
                existing_messages.add((row[2], row[3]))  # username, message

        new_messages = []
        for username, message in processed_lines:
            if (username, message) not in existing_messages:
                new_messages.append((username, message))
                existing_messages.add((username, message))

        return new_messages

    def set_log_file(self, log_file):
        self.log_file = log_file

Main.py:
import sys
from PyQt5.QtWidgets import QApplication
from ui import PipsChatAnalyserUI

def main():
    app = QApplication(sys.argv)
    main_window = PipsChatAnalyserUI()
    main_window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()

ollama.py:
import requests
import logging
import time

class OllamaAPI:
    def __init__(self, base_url, model):
        self.base_url = base_url
        self.model = model
        self.max_retries = 3
        self.timeout = 120  # Increased timeout to 60 seconds

    def send_request(self, system_prompt, instruction, text):
        url = f"{self.base_url}/api/generate"
        full_prompt = f"{system_prompt}\n\n{instruction}\n\nHuman: {text}\n\nAssistant:"
        
        data = {
            "model": self.model,
            "prompt": full_prompt,
            "stream": False
        }
        
        for attempt in range(self.max_retries):
            try:
                response = requests.post(url, json=data, timeout=self.timeout)
                response.raise_for_status()
                json_response = response.json()
                logging.info(f"Ollama API response received for prompt: {text[:50]}...")
                return json_response.get('response', '')
            except requests.exceptions.RequestException as e:
                logging.warning(f"Attempt {attempt + 1} failed: {str(e)}")
                if attempt < self.max_retries - 1:
                    time.sleep(2 ** attempt)  # Exponential backoff
                else:
                    logging.error(f"Error communicating with Ollama after {self.max_retries} attempts: {str(e)}")
                    raise

ollama_handler.py:
import time
import logging
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QLabel, QProgressBar
from PyQt5.QtCore import Qt, QTimer
import pyautogui

class OllamaResponseHandler(QDialog):
    def __init__(self, parent, ollama_api, system_prompt, user_prompt, user_message, chat_input_position):
        super().__init__(parent)
        self.ollama_api = ollama_api
        self.system_prompt = system_prompt
        self.user_prompt = user_prompt
        self.user_message = user_message
        self.chat_input_position = chat_input_position
        self.response = None
        self.error = None

        self.initUI()

    def initUI(self):
        self.setWindowTitle("AI Response")
        self.setFixedSize(300, 100)
        layout = QVBoxLayout()

        self.status_label = QLabel("Replying with AI...", self)
        layout.addWidget(self.status_label)

        self.progress_bar = QProgressBar(self)
        self.progress_bar.setRange(0, 0)  # Indeterminate progress
        layout.addWidget(self.progress_bar)

        self.setLayout(layout)

    def process_response(self):
        self.show()
        QTimer.singleShot(100, self._process)

    def _process(self):
        try:
            logging.info("AI Response: Sending chat to AI...")
            self.status_label.setText("Sending chat to AI...")
            self.response = self.ollama_api.send_request(self.system_prompt, self.user_prompt, self.user_message)
            
            logging.info("AI Response: Reply generated")
            self.status_label.setText("Reply generated")
            time.sleep(1)

            logging.info("AI Response: Finding chat box...")
            self.status_label.setText("Finding chat box...")
            pyautogui.click(self.chat_input_position.x, self.chat_input_position.y)
            time.sleep(1)

            logging.info("AI Response: Entering chat text...")
            self.status_label.setText("Entering chat text...")
            pyautogui.typewrite(self.response)
            time.sleep(1)

            logging.info("AI Response: Submitting chat text...")
            self.status_label.setText("Submitting chat text...")
            pyautogui.press('enter')
            time.sleep(1)

        except Exception as e:
            self.error = str(e)
            logging.error(f"AI Response Error: {self.error}")
            self.status_label.setText(f"Error: {self.error}")
            time.sleep(3)

        finally:
            logging.info("AI Response: Process completed")
            self.close()

def handle_ollama_response(parent, ollama_api, system_prompt, user_prompt, user_message, chat_input_position):
    handler = OllamaResponseHandler(parent, ollama_api, system_prompt, user_prompt, user_message, chat_input_position)
    handler.process_response()
    return handler.response, handler.error

settings.py:
from PyQt5.QtWidgets import (QDialog, QVBoxLayout, QFormLayout, QLineEdit, QPushButton, 
                             QLabel, QSpinBox, QTextEdit, QMessageBox, QHBoxLayout)
from PyQt5.QtCore import Qt, QThread, pyqtSignal
from utils import load_settings, save_settings
from ollama import OllamaAPI

class TestOllamaThread(QThread):
    test_complete = pyqtSignal(bool, str)

    def __init__(self, url, model):
        super().__init__()
        self.url = url
        self.model = model

    def run(self):
        try:
            ollama_api = OllamaAPI(self.url, self.model)
            response = ollama_api.send_request("Test prompt", "This is a test message.", "Hello, Ollama!")
            self.test_complete.emit(True, response)
        except Exception as e:
            self.test_complete.emit(False, str(e))

class SettingsDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Settings")
        self.setModal(True)
        self.initUI()
        self.load_current_settings()

    def initUI(self):
        layout = QVBoxLayout(self)

        form_layout = QFormLayout()

        self.ollama_url_input = QLineEdit(self)
        form_layout.addRow("Ollama URL:", self.ollama_url_input)

        self.model_input = QLineEdit(self)
        form_layout.addRow("Model:", self.model_input)

        test_layout = QHBoxLayout()
        self.test_ollama_button = QPushButton("Test Ollama", self)
        self.test_ollama_button.clicked.connect(self.test_ollama)
        test_layout.addWidget(self.test_ollama_button)
        form_layout.addRow("", test_layout)

        self.capture_interval_input = QSpinBox(self)
        self.capture_interval_input.setRange(1, 3600)
        form_layout.addRow("Capture Interval (seconds):", self.capture_interval_input)

        self.my_username_input = QLineEdit(self)
        form_layout.addRow("My Username:", self.my_username_input)

        self.other_usernames_input = QLineEdit(self)
        form_layout.addRow("Other Usernames (comma-separated):", self.other_usernames_input)

        self.prompt_input = QTextEdit(self)
        self.prompt_input.setFixedHeight(100)
        form_layout.addRow("Prompt:", self.prompt_input)

        self.ignored_lines_input = QTextEdit(self)
        self.ignored_lines_input.setFixedHeight(100)
        form_layout.addRow("Ignored Lines Format (one per line):", self.ignored_lines_input)

        layout.addLayout(form_layout)

        save_button = QPushButton("Save", self)
        save_button.clicked.connect(self.save_settings)
        layout.addWidget(save_button)

    def load_current_settings(self):
        settings = load_settings()
        self.ollama_url_input.setText(settings['ollama_url'])
        self.model_input.setText(settings['model'])
        self.capture_interval_input.setValue(settings['capture_interval'])
        self.my_username_input.setText(settings['my_username'])
        self.other_usernames_input.setText(", ".join(settings['other_usernames']))
        self.prompt_input.setPlainText(settings['prompt'])
        self.ignored_lines_input.setPlainText("\n".join(settings.get('ignored_lines', [])))

    def save_settings(self):
        new_settings = {
            'ollama_url': self.ollama_url_input.text(),
            'model': self.model_input.text(),
            'capture_interval': self.capture_interval_input.value(),
            'my_username': self.my_username_input.text(),
            'other_usernames': [username.strip() for username in self.other_usernames_input.text().split(',') if username.strip()],
            'prompt': self.prompt_input.toPlainText(),
            'ignored_lines': [line.strip() for line in self.ignored_lines_input.toPlainText().split('\n') if line.strip()]
        }
        save_settings(new_settings)
        self.accept()

    def test_ollama(self):
        url = self.ollama_url_input.text()
        model = self.model_input.text()
        self.test_thread = TestOllamaThread(url, model)
        self.test_thread.test_complete.connect(self.on_test_complete)
        self.test_thread.start()
        QMessageBox.information(self, "Testing Ollama", "Testing connection to Ollama. Please wait...")

    def on_test_complete(self, success, message):
        if success:
            QMessageBox.information(self, "Test Successful", f"Successfully connected to Ollama.\nResponse: {message}")
        else:
            QMessageBox.critical(self, "Test Failed", f"Failed to connect to Ollama.\nError: {message}")

ui.py:
import logging
import time
from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox, QTextEdit, QVBoxLayout, QPushButton, QWidget, QHBoxLayout, QLabel, QLineEdit
from PyQt5.QtCore import Qt, QTimer, pyqtSlot, pyqtSignal, QObject
import pyautogui
from utils import load_settings, save_settings, create_new_log_file
from ollama import OllamaAPI
from settings import SettingsDialog
from analyzer import TransparentWindow
from capture_handler import CaptureHandler
from ai_handler import AIHandler

class LogHandler(QObject):
    log_message = pyqtSignal(str)

class ThreadSafeLogger(logging.Handler):
    def __init__(self, log_widget):
        super().__init__()
        self.log_handler = LogHandler()
        self.log_handler.log_message.connect(log_widget.append)

    def emit(self, record):
        msg = self.format(record)
        self.log_handler.log_message.emit(msg)

class PipsChatAnalyserUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.is_analyzing = False
        self.log_file = None
        self.ollama_api = None
        self.ai_handler = None
        self.capture_interval = 30  # seconds
        self.prompt_text = ""
        self.my_username = ""
        self.other_usernames = []
        self.ignored_patterns = []
        self.chat_input_position = None
        self.chat_input_position_display = None
        self.initUI()
        self.load_settings()
        self.init_analyzer()
        self.init_capture_handler()
        self.init_ai_handler()

    def initUI(self):
        self.setWindowTitle("PIPS CHAT ANALYSER")
        self.setGeometry(100, 100, 800, 600)
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)
        
        # Background Prompt
        layout.addWidget(QLabel("Background Prompt"))
        self.background_prompt = QTextEdit(self)
        self.background_prompt.setPlainText(self.prompt_text)
        self.background_prompt.setFixedHeight(4 * self.background_prompt.fontMetrics().lineSpacing())
        layout.addWidget(self.background_prompt)

        # Save and Settings buttons
        button_layout = QHBoxLayout()
        self.save_button = QPushButton("Save", self)
        self.save_button.clicked.connect(self.save_settings)
        button_layout.addWidget(self.save_button)
        
        self.settings_button = QPushButton("Settings", self)
        self.settings_button.clicked.connect(self.open_settings)
        button_layout.addWidget(self.settings_button)
        layout.addLayout(button_layout)
        
        # Username inputs
        username_layout = QHBoxLayout()
        self.my_username_input = QLineEdit(self)
        self.my_username_input.setPlaceholderText("My username")
        username_layout.addWidget(QLabel("My Username:"))
        username_layout.addWidget(self.my_username_input)
        
        self.other_usernames_input = QLineEdit(self)
        self.other_usernames_input.setPlaceholderText("Other usernames (comma-separated)")
        username_layout.addWidget(QLabel("Other Usernames:"))
        username_layout.addWidget(self.other_usernames_input)
        layout.addLayout(username_layout)
        
        # Chat log
        layout.addWidget(QLabel("Chat log and information"))
        self.chat_log = QTextEdit(self)
        self.chat_log.setReadOnly(True)
        layout.addWidget(self.chat_log)

        # Set up logging to the QTextEdit
        self.setup_logging()

        # Last captured line display
        self.last_captured_line = QLineEdit(self)
        self.last_captured_line.setReadOnly(True)
        layout.addWidget(QLabel("Last Captured Line:"))
        layout.addWidget(self.last_captured_line)

        # Chat input position display
        self.chat_input_position_display = QLineEdit(self)
        self.chat_input_position_display.setReadOnly(True)
        layout.addWidget(QLabel("Chat text position:"))
        layout.addWidget(self.chat_input_position_display)

        # Capture, Start, and Stop buttons
        button_layout = QHBoxLayout()
        self.capture_button = QPushButton("Capture", self)
        self.capture_button.clicked.connect(self.capture_analysis)
        button_layout.addWidget(self.capture_button)
        
        self.start_button = QPushButton("Start", self)
        self.start_button.clicked.connect(self.start_analysis)
        button_layout.addWidget(self.start_button)

        self.stop_button = QPushButton("Stop", self)
        self.stop_button.clicked.connect(self.stop_analysis)
        button_layout.addWidget(self.stop_button)

        layout.addLayout(button_layout)

    def setup_logging(self):
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        
        # File handler
        file_handler = logging.FileHandler('application_log.txt')
        file_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        logger.addHandler(file_handler)
        
        # Thread-safe handler for QTextEdit
        text_handler = ThreadSafeLogger(self.chat_log)
        text_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        logger.addHandler(text_handler)

    def init_analyzer(self):
        self.analyzer_window = TransparentWindow()
        self.analyzer_window.show()

    def init_capture_handler(self):
        self.capture_handler = CaptureHandler(self.analyzer_window, self.my_username, self.other_usernames, self.ignored_patterns)
        self.capture_handler.capture_complete.connect(self.on_capture_complete)
        self.capture_handler.new_message_detected.connect(self.on_new_message_detected)

    def init_ai_handler(self):
        self.ai_handler = AIHandler(self.ollama_api, self.prompt_text)

    def load_settings(self):
        settings = load_settings()
        self.ollama_api = OllamaAPI(settings['ollama_url'], settings['model'])
        self.capture_interval = settings['capture_interval']
        self.prompt_text = settings.get('prompt', '')
        self.my_username = settings.get('my_username', '')
        self.other_usernames = settings.get('other_usernames', [])
        self.ignored_patterns = settings.get('ignored_lines', [])
        chat_input_position = settings.get('chat_input_position', {})
        if chat_input_position:
            self.chat_input_position = pyautogui.Point(x=chat_input_position['x'], y=chat_input_position['y'])
            if self.chat_input_position_display:
                self.chat_input_position_display.setText(f"x={self.chat_input_position.x}, y={self.chat_input_position.y}")
        
        self.background_prompt.setPlainText(self.prompt_text)
        self.my_username_input.setText(self.my_username)
        self.other_usernames_input.setText(", ".join(self.other_usernames))
        
        if self.ai_handler:
            self.ai_handler.set_background_prompt(self.prompt_text)
        
        logging.info(f"Loaded prompt: {self.prompt_text}")
        logging.info(f"Loaded my username: {self.my_username}")
        logging.info(f"Loaded other usernames: {self.other_usernames}")
        logging.info(f"Loaded ignored patterns: {self.ignored_patterns}")
        logging.info(f"Loaded chat input position: {self.chat_input_position}")

    def save_settings(self):
        settings = {
            'prompt': self.background_prompt.toPlainText(),
            'my_username': self.my_username_input.text(),
            'other_usernames': [username.strip() for username in self.other_usernames_input.text().split(',') if username.strip()],
            'ollama_url': self.ollama_api.base_url,
            'model': self.ollama_api.model,
            'capture_interval': self.capture_interval,
            'ignored_lines': self.ignored_patterns,
            'chat_input_position': {'x': self.chat_input_position.x, 'y': self.chat_input_position.y} if self.chat_input_position else {}
        }
        save_settings(settings)
        self.load_settings()  # Reload settings after saving
        QMessageBox.information(self, "Success", "Settings saved successfully.")

    def open_settings(self):
        settings_dialog = SettingsDialog(self)
        if settings_dialog.exec_():
            self.load_settings()

    def capture_analysis(self):
        self.capture_button.setEnabled(False)
        self.log_file = create_new_log_file()
        logging.info(f"Screen capture output saved in: {self.log_file}")
        self.capture_handler.set_log_file(self.log_file)
        self.capture_handler.start_capture()

    @pyqtSlot(list)
    def on_capture_complete(self, processed_lines):
        if processed_lines:
            self.last_captured_line.setText(processed_lines[-1][1])
        self.capture_button.setEnabled(True)

    def start_analysis(self):
        if not self.log_file:
            logging.error("Error: No capture performed. Please capture first.")
            QMessageBox.warning(self, "Error", "No capture performed. Please capture first.")
            return
        
        self.is_analyzing = True
        self.start_button.setEnabled(False)
        logging.info("System: Analysis started")

        if not self.chat_input_position:
            QMessageBox.information(self, "Chat Input Position", "You have 5 seconds to click on the chat input field.")
            QTimer.singleShot(5000, self.set_chat_input_position)
        else:
            self.continuous_analysis()

    def set_chat_input_position(self):
        self.chat_input_position = pyautogui.position()
        self.chat_input_position_display.setText(f"x={self.chat_input_position.x}, y={self.chat_input_position.y}")
        logging.info(f"Chat input position set to: Point(x={self.chat_input_position.x}, y={self.chat_input_position.y})")
        self.continuous_analysis()

    def continuous_analysis(self):
        if self.is_analyzing:
            logging.info(f"{self.capture_interval} sec before next screen refresh")
            QTimer.singleShot(self.capture_interval * 1000, self.capture_handler.start_capture)

    @pyqtSlot(str, str)
    def on_new_message_detected(self, username, message):
        response, error = self.ai_handler.process_new_message(self.log_file, username, message, self.chat_input_position)
        if error:
            QMessageBox.warning(self, "Error", f"An error occurred while processing the AI response: {error}")
        else:
            self.capture_handler.append_to_csv(self.log_file, "ollama_response", "Ollama", response)

    def stop_analysis(self):
        self.is_analyzing = False
        self.start_button.setEnabled(True)
        logging.info("System: Analysis stopped")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    main_window = PipsChatAnalyserUI()
    main_window.show()
    sys.exit(app.exec_())

utils.py:
import json
import os
import csv
import logging
import re
from PyQt5.QtCore import QSettings
from datetime import datetime

def load_settings():
    settings = QSettings("PipsChat", "ChatAnalyzer")
    try:
        with open('settings.json', 'r') as f:
            file_settings = json.load(f)
    except FileNotFoundError:
        file_settings = {}
    
    return {
        'ollama_url': file_settings.get('ollama_url') or settings.value("ollama_url", "http://localhost:11434"),
        'model': file_settings.get('model') or settings.value("model", "llama2"),
        'capture_interval': int(file_settings.get('capture_interval') or settings.value("capture_interval", 15)),
        'prompt': file_settings.get('prompt') or settings.value("prompt", ""),
        'my_username': file_settings.get('my_username') or settings.value("my_username", ""),
        'other_usernames': file_settings.get('other_usernames') or settings.value("other_usernames", []),
        'ignored_lines': file_settings.get('ignored_lines') or settings.value("ignored_lines", []),
        'chat_input_position': file_settings.get('chat_input_position') or settings.value("chat_input_position", {})
    }

def save_settings(settings):
    q_settings = QSettings("PipsChat", "ChatAnalyzer")
    for key, value in settings.items():
        q_settings.setValue(key, value)
    
    with open('settings.json', 'w') as f:
        json.dump(settings, f, indent=4)

def create_new_log_file():
    log_folder = './logs'
    if not os.path.exists(log_folder):
        os.makedirs(log_folder)

    i = 1
    while os.path.exists(f"{log_folder}/chatlog{i:04d}.csv"):
        i += 1
    
    log_file = f"{log_folder}/chatlog{i:04d}.csv"
    
    with open(log_file, mode='w', newline='', encoding='utf-8') as file:
        writer = csv.writer(file)
        writer.writerow(["ID", "Conversation", "Username", "Message"])
    
    return log_file

def append_to_csv(log_file, conversation_type, username, message):
    with open(log_file, mode='a', newline='', encoding='utf-8') as file:
        writer = csv.writer(file)
        
        with open(log_file, mode='r', newline='', encoding='utf-8') as readfile:
            lines = list(csv.reader(readfile))
            last_id = int(lines[-1][0]) if len(lines) > 1 else 0
        
        writer.writerow([f"{last_id + 1:04d}", conversation_type, username, message])

class QTextEditLogger(logging.Handler):
    def __init__(self, widget):
        super().__init__()
        self.widget = widget
        self.widget.setReadOnly(True)

    def emit(self, record):
        msg = self.format(record)
        self.widget.append(msg)

def setup_logging(log_widget):
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    # File handler
    file_handler = logging.FileHandler('application_log.txt')
    file_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
    logger.addHandler(file_handler)
    
    # Widget handler
    widget_handler = QTextEditLogger(log_widget)
    widget_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
    logger.addHandler(widget_handler)

def is_ignored_line(line, ignored_patterns):
    # Check if the line matches any of the ignored patterns
    for pattern in ignored_patterns:
        if re.search(pattern, line):
            return True
    
    # Check for date formats
    date_patterns = [
        r"\w+,\s+\w+\s+\d{1,2}(st|nd|rd|th)\s+v",  # e.g., "Friday, September 13th v"
        r"Today\s+v",
        r"\w+\s+\d{1,2}(st|nd|rd|th),\s+\d{4}"  # e.g., "September 16th, 2024"
    ]
    
    for pattern in date_patterns:
        if re.search(pattern, line):
            return True
    
    return False

def process_captured_text(text, my_username, other_usernames, ignored_patterns):
    logging.debug(f"Processing captured text: {text[:100]}...")  # Log first 100 characters
    lines = text.split('\n')
    processed_lines = []
    all_usernames = [my_username] + other_usernames
    
    for line in lines:
        line = line.strip()
        if line and not is_ignored_line(line, ignored_patterns):
            username = ''
            message = line
            
            for name in all_usernames:
                if line.startswith(name):
                    username = name
                    message = line[len(name):].strip()
                    break
            
            # Replace '|' with 'I' at the beginning of the line
            message = re.sub(r'^[|]', 'I', message)
            # Replace isolated '|' with 'I'
            message = re.sub(r'\s[|]\s', ' I ', message)
            
            processed_lines.append((username, message))
    
    logging.debug(f"Processed {len(processed_lines)} lines")
    return processed_lines

