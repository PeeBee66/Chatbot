Date: 2024-09-24 13:04:39

ai_handler.py:
import logging
from PyQt5.QtCore import QObject, pyqtSignal, QThread
from PyQt5.QtWidgets import QProgressDialog
from ollama_handler import handle_ollama_response

class OllamaWorker(QThread):
    finished = pyqtSignal(str, str)

    def __init__(self, ollama_api, system_prompt, username, message, chat_input_position):
        super().__init__()
        self.ollama_api = ollama_api
        self.system_prompt = system_prompt
        self.username = username
        self.message = message
        self.chat_input_position = chat_input_position

    def run(self):
        response, error = handle_ollama_response(
            None,  # We don't need the parent widget here
            self.ollama_api,
            self.system_prompt,
            f"Please respond to the following message from {self.username}:",
            self.message,
            self.chat_input_position
        )
        self.finished.emit(response, error)

class AIHandler(QObject):
    response_ready = pyqtSignal(str, str)

    def __init__(self, ollama_api, background_prompt):
        super().__init__()
        self.ollama_api = ollama_api
        self.background_prompt = background_prompt

    def process_new_message(self, log_file, username, message, chat_input_position):
        # Create and show progress dialog
        progress = QProgressDialog("Processing message...", "Cancel", 0, 0)
        progress.setWindowTitle("AI Response")
        progress.setModal(True)
        progress.show()

        # Create worker thread
        self.worker = OllamaWorker(self.ollama_api, self.background_prompt, username, message, chat_input_position)
        self.worker.finished.connect(self.on_worker_finished)
        self.worker.finished.connect(progress.close)
        self.worker.start()

    def on_worker_finished(self, response, error):
        if error:
            logging.error(f"Error in Ollama response: {error}")
        else:
            logging.info(f"Ollama's response: {response}")
        self.response_ready.emit(response, error)

    def set_background_prompt(self, prompt):
        self.background_prompt = prompt

analysis.py:
from PyQt5.QtCore import QThread, pyqtSignal
from ollama import OllamaAPI
import csv
import logging

class AnalysisThread(QThread):
    analysis_complete = pyqtSignal(str)

    def __init__(self, log_file, background_prompt, ollama_api):
        super().__init__()
        self.log_file = log_file
        self.background_prompt = background_prompt
        self.ollama_api = ollama_api

    def run(self):
        response = self.start_conversation()
        self.analysis_complete.emit(response)

    def start_conversation(self):
        try:
            with open(self.log_file, mode='r', newline='', encoding='utf-8') as file:
                reader = csv.reader(file)
                next(reader)  # Skip header
                chat_history = [f"{row[1]}: {row[2]}" for row in reader]
            
            chat_history_text = "\n".join(chat_history)
            prompt = f"{self.background_prompt}\n\n{chat_history_text}"
            logging.info("Contacting Ollama server: Please wait for response (this may take a bit depending on AI assistant speeds)")
            response = self.ollama_api.send_request(self.background_prompt, "Please respond to the following conversation.", chat_history_text)
            logging.info("Received response from Ollama server")
            
            return response
        except Exception as e:
            logging.error(f"Error starting conversation: {str(e)}")
            return ""

def process_new_message(message, background_prompt, ollama_api):
    try:
        logging.info("Contacting Ollama server: Please wait for response (this may take a bit depending on AI assistant speeds)")
        response = ollama_api.send_request(background_prompt, 
                                           "Please respond to the following message:", 
                                           message)
        logging.info("Received response from Ollama server")
        return response
    except Exception as e:
        logging.error(f"Error processing new message: {str(e)}")
        return ""

def get_chat_history(log_file):
    try:
        with open(log_file, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.reader(file)
            next(reader)  # Skip header
            return [f"{row[1]}: {row[2]}" for row in reader]
    except Exception as e:
        logging.error(f"Error reading chat history: {str(e)}")
        return []

def analyze_conversation(chat_history, background_prompt, ollama_api):
    chat_history_text = "\n".join(chat_history)
    prompt = f"{background_prompt}\n\n{chat_history_text}"
    try:
        response = ollama_api.send_request(background_prompt, 
                                           "Please analyze the following conversation:", 
                                           chat_history_text)
        return response
    except Exception as e:
        logging.error(f"Error analyzing conversation: {str(e)}")
        return ""

analyzer.py:
import logging
import pytesseract
from PIL import Image, ImageGrab, ImageOps, ImageEnhance
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QSizeGrip, QPushButton
from PyQt5.QtCore import Qt, pyqtSignal, QSize, QRect
from PyQt5.QtGui import QPainter, QColor, QPen
import traceback

class TransparentWindow(QWidget):
    text_captured = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.min_size = QSize(400, 300)
        self.border_width = 2
        self.corner_size = 10
        self.capture_inset = 5  # Inset for the dotted line
        self.capture_reduction = 1  # Reduction of actual capture area (1 pixel â‰ˆ 0.25mm)
        self.initUI()
        self.oldPos = None
        
        pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'
        logging.info(f"Tesseract path set to: {pytesseract.pytesseract.tesseract_cmd}")
        
        try:
            logging.info(f"Tesseract version: {pytesseract.get_tesseract_version()}")
        except Exception as e:
            logging.error(f"Error getting Tesseract version: {str(e)}")

    def initUI(self):
        self.setWindowTitle('Chat Analyzer')
        self.setGeometry(100, 100, 500, 400)
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setMinimumSize(self.min_size)

        layout = QVBoxLayout()
        self.setLayout(layout)

        # Add close button
        self.close_button = QPushButton("X", self)
        self.close_button.setStyleSheet("background-color: red; color: white;")
        self.close_button.setFixedSize(20, 20)
        self.close_button.clicked.connect(self.close)
        
        size_grip = QSizeGrip(self)
        layout.addWidget(size_grip, 0, Qt.AlignBottom | Qt.AlignRight)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Draw semi-transparent background
        painter.setBrush(QColor(0, 0, 0, 50))
        painter.setPen(Qt.NoPen)
        painter.drawRect(self.rect())
        
        # Draw border
        painter.setPen(QPen(QColor(255, 255, 255), self.border_width, Qt.SolidLine))
        painter.drawRect(self.rect().adjusted(self.border_width//2, self.border_width//2, -self.border_width//2, -self.border_width//2))
        
        # Draw capture area with light grey, thin line
        capture_area = self.get_visible_capture_area()
        painter.setPen(QPen(QColor(200, 200, 200), 1, Qt.DashLine))
        painter.drawRect(capture_area)

        # Position close button
        self.close_button.move(self.width() - 25, 5)

    def mousePressEvent(self, event):
        self.oldPos = event.globalPos()

    def mouseMoveEvent(self, event):
        if self.oldPos:
            delta = event.globalPos() - self.oldPos
            self.move(self.pos() + delta)
            self.oldPos = event.globalPos()

    def mouseReleaseEvent(self, event):
        self.oldPos = None

    def get_visible_capture_area(self):
        return self.rect().adjusted(
            self.border_width + self.capture_inset,
            self.border_width + self.capture_inset,
            -self.corner_size - self.border_width - self.capture_inset,
            -self.corner_size - self.border_width - self.capture_inset
        )

    def get_actual_capture_area(self):
        visible_area = self.get_visible_capture_area()
        return visible_area.adjusted(
            self.capture_reduction,
            self.capture_reduction,
            -self.capture_reduction,
            -self.capture_reduction
        )

    def capture_screen(self):
        try:
            logging.debug("Entering capture_screen method")
            
            capture_area = self.get_actual_capture_area()
            top_left = self.mapToGlobal(capture_area.topLeft())
            x, y = top_left.x(), top_left.y()
            w, h = capture_area.width(), capture_area.height()
            logging.info(f"Capture coordinates: x={x}, y={y}, w={w}, h={h}")
            
            screenshot = ImageGrab.grab(bbox=(x, y, x + w, y + h))
            screenshot.save("debug_screenshot.png")
            
            screenshot = screenshot.convert('L')
            screenshot = ImageOps.invert(screenshot)
            enhancer = ImageEnhance.Contrast(screenshot)
            screenshot = enhancer.enhance(2)
            
            custom_config = r'--oem 3 --psm 6'
            text = pytesseract.image_to_string(screenshot, config=custom_config)
            
            logging.debug(f"OCR completed. Captured text length: {len(text)}")
            if not text:
                logging.warning("No text captured by Tesseract")
            else:
                logging.debug(f"Captured text: {text}")
                self.text_captured.emit(text)
            
            return text
        except Exception as e:
            logging.error(f"Unexpected error in capture_screen: {str(e)}")
            logging.error(traceback.format_exc())
            return ""

    def resizeEvent(self, event):
        super().resizeEvent(event)

    def closeEvent(self, event):
        logging.info("Closing TransparentWindow")
        super().closeEvent(event)

backup_py.py:
import os
from datetime import datetime

def backup_py_files():
    # Get the current date and time
    current_date = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Create/open the backup text file
    with open("backup_py.txt", "w") as backup_file:
        # Write the current date at the top
        backup_file.write(f"Date: {current_date}\n\n")
        
        # Iterate over all files in the current directory
        for filename in os.listdir('.'):
            # Check if the file is a Python file
            if filename.endswith(".py"):
                # Write the filename
                backup_file.write(f"{filename}:\n")
                
                # Open and write the contents of the Python file
                with open(filename, "r") as py_file:
                    code = py_file.read()
                    backup_file.write(code)
                    backup_file.write("\n\n")  # Add some spacing between files

    print("Backup complete! All Python files have been saved to backup_py.txt.")

# Run the function to create the backup
backup_py_files()


capture.py:
from PyQt5.QtCore import QThread, pyqtSignal
from utils import process_captured_text
import logging

class CaptureThread(QThread):
    capture_complete = pyqtSignal(list)

    def __init__(self, analyzer_window, my_username, other_usernames, ignored_patterns):
        super().__init__()
        self.analyzer_window = analyzer_window
        self.my_username = my_username
        self.other_usernames = other_usernames
        self.ignored_patterns = ignored_patterns

    def run(self):
        try:
            logging.debug("CaptureThread started")
            text = self.analyzer_window.capture_screen()
            logging.debug(f"Raw captured text: {text[:100]}...")  # Log first 100 characters
            processed_lines = process_captured_text(text, self.my_username, self.other_usernames, self.ignored_patterns)
            logging.debug(f"Processed lines: {processed_lines}")
            self.capture_complete.emit(processed_lines)
        except Exception as e:
            logging.error(f"Error in CaptureThread: {str(e)}", exc_info=True)

capture_handler.py:
import logging
from PyQt5.QtCore import QObject, pyqtSignal, pyqtSlot
from utils import process_captured_text, append_to_csv, get_last_messages

class CaptureHandler(QObject):
    capture_complete = pyqtSignal(list)
    new_message_detected = pyqtSignal(str, str)

    def __init__(self, analyzer_window, my_username, other_usernames, ignored_patterns):
        super().__init__()
        self.analyzer_window = analyzer_window
        self.my_username = my_username
        self.other_usernames = other_usernames
        self.ignored_patterns = ignored_patterns
        self.log_file = None
        self.last_processed_message = None

    def set_log_file(self, log_file):
        self.log_file = log_file
        logging.info(f"Log file set to: {log_file}")

    def reset_capture_state(self):
        self.last_processed_message = None
        logging.info("Capture state reset")

    def start_capture(self):
        try:
            logging.info("System: Capture initiated")
            text = self.analyzer_window.capture_screen()
            self.handle_captured_text(text)
        except Exception as e:
            logging.error(f"Error in start_capture: {str(e)}", exc_info=True)

    def handle_captured_text(self, text):
        processed_lines = process_captured_text(text, self.my_username, self.other_usernames, self.ignored_patterns)
        logging.info(f"Processed {len(processed_lines)} lines")
        self.capture_complete.emit(processed_lines)

    def check_for_new_messages(self, processed_lines):
        new_messages = self.get_new_messages(processed_lines)
        if new_messages:
            for username, message in new_messages:
                if username in self.other_usernames:
                    self.new_message_detected.emit(username, message)
            return new_messages[-1][1]  # Return the last captured line
        else:
            logging.info("No new user messages detected.")
            return None

    def get_new_messages(self, processed_lines):
        if not self.last_processed_message:
            return processed_lines
        
        new_messages = []
        found_last_message = False
        for message in processed_lines:
            if found_last_message:
                new_messages.append(message)
            elif message == self.last_processed_message:
                found_last_message = True
        
        return new_messages

chat_position_handler.py:
import logging
from PyQt5.QtCore import QObject, pyqtSignal, QTimer
from PyQt5.QtWidgets import QMessageBox
import pyautogui

class ChatPositionHandler(QObject):
    position_set = pyqtSignal(int, int)

    def __init__(self):
        super().__init__()
        self.chat_input_position = None

    def set_chat_position(self):
        QMessageBox.information(None, "Set Chat Position", "Click on the chat input field in 3 seconds.")
        QTimer.singleShot(3000, self._capture_chat_position)

    def _capture_chat_position(self):
        self.chat_input_position = pyautogui.position()
        logging.info(f"Chat input position set to: x={self.chat_input_position.x}, y={self.chat_input_position.y}")
        QMessageBox.information(None, "Success", "Chat position has been set.")
        self.position_set.emit(self.chat_input_position.x, self.chat_input_position.y)

    def get_chat_position(self):
        return self.chat_input_position

    def set_chat_position_from_settings(self, x, y):
        self.chat_input_position = pyautogui.Point(x=x, y=y)

    def has_position(self):
        return self.chat_input_position is not None

    def click_chat_input(self):
        if self.chat_input_position:
            pyautogui.click(self.chat_input_position.x, self.chat_input_position.y)
        else:
            logging.warning("Attempted to click chat input, but position is not set.")

    def type_message(self, message):
        if self.chat_input_position and message:
            self.click_chat_input()
            pyautogui.typewrite(str(message))  # Convert to string for safety
            pyautogui.press('enter')
        else:
            logging.warning("Attempted to type message, but chat input position is not set or message is empty.")

Main.py:
import sys
import logging
import traceback
from PyQt5.QtWidgets import QApplication, QMessageBox
from ui import PipsChatAnalyserUI

def setup_logging():
    logging.basicConfig(
        filename='app.log',
        level=logging.DEBUG,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console = logging.StreamHandler()
    console.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')
    console.setFormatter(formatter)
    logging.getLogger('').addHandler(console)

def exception_hook(exctype, value, tb):
    logging.critical('Unhandled exception:', exc_info=(exctype, value, tb))
    error_msg = f"An unhandled exception occurred:\n{exctype.__name__}: {str(value)}\n\nTraceback:\n{''.join(traceback.format_tb(tb))}"
    print(error_msg)  # Print to console as well
    QMessageBox.critical(None, "Critical Error", error_msg)
    sys.__excepthook__(exctype, value, tb)

def main():
    setup_logging()
    sys.excepthook = exception_hook
    logging.info("Starting PIPS CHAT ANALYSER")
    
    try:
        app = QApplication(sys.argv)
    except Exception as e:
        logging.critical(f"Error creating QApplication: {str(e)}", exc_info=True)
        print(f"Error creating QApplication: {str(e)}")
        return

    try:
        main_window = PipsChatAnalyserUI()
        main_window.show()
        sys.exit(app.exec_())
    except Exception as e:
        logging.critical(f"Critical error in main application: {str(e)}", exc_info=True)
        print(f"Critical error in main application: {str(e)}")

if __name__ == "__main__":
    main()

ollama.py:
import requests
import logging
import time
from requests.exceptions import RequestException, Timeout, ConnectionError

class OllamaAPI:
    def __init__(self, base_url, model):
        self.base_url = base_url
        self.model = model
        self.max_retries = 3
        self.timeout = 120  # Increased timeout to 60 seconds

    def send_request(self, system_prompt, instruction, text):
        url = f"{self.base_url}/api/generate"
        full_prompt = f"{system_prompt}\n\n{instruction}\n\nHuman: {text}\n\nAssistant:"
        
        data = {
            "model": self.model,
            "prompt": full_prompt,
            "stream": False
        }
        
        for attempt in range(self.max_retries):
            try:
                response = requests.post(url, json=data, timeout=self.timeout)
                response.raise_for_status()
                json_response = response.json()
                logging.info(f"Ollama API response received for prompt: {text[:50]}...")
                return json_response.get('response', '')
            except Timeout:
                logging.warning(f"Attempt {attempt + 1} timed out. Retrying...")
            except ConnectionError:
                logging.warning(f"Attempt {attempt + 1} failed due to connection error. Retrying...")
            except RequestException as e:
                logging.error(f"Attempt {attempt + 1} failed with error: {str(e)}")
                if attempt == self.max_retries - 1:
                    raise
            
            time.sleep(2 ** attempt)  # Exponential backoff
        
        raise Exception(f"Failed to get response from Ollama API after {self.max_retries} attempts")

ollama_handler.py:
import time
import logging
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QLabel, QProgressBar
from PyQt5.QtCore import Qt, QTimer
import pyautogui

class OllamaResponseHandler(QDialog):
    def __init__(self, parent, ollama_api, system_prompt, user_prompt, user_message, chat_input_position):
        super().__init__(parent)
        self.ollama_api = ollama_api
        self.system_prompt = system_prompt
        self.user_prompt = user_prompt
        self.user_message = user_message
        self.chat_input_position = chat_input_position
        self.response = None
        self.error = None

        self.initUI()

    def initUI(self):
        self.setWindowTitle("AI Response")
        self.setFixedSize(300, 100)
        layout = QVBoxLayout()

        self.status_label = QLabel("Replying with AI...", self)
        layout.addWidget(self.status_label)

        self.progress_bar = QProgressBar(self)
        self.progress_bar.setRange(0, 0)  # Indeterminate progress
        layout.addWidget(self.progress_bar)

        self.setLayout(layout)

    def process_response(self):
        self.show()
        QTimer.singleShot(100, self._process)

    def _process(self):
        try:
            logging.info("AI Response: Sending chat to AI...")
            self.status_label.setText("Sending chat to AI...")
            self.response = self.ollama_api.send_request(self.system_prompt, self.user_prompt, self.user_message)
            
            logging.info("AI Response: Reply generated")
            self.status_label.setText("Reply generated")
            time.sleep(1)

            logging.info("AI Response: Finding chat box...")
            self.status_label.setText("Finding chat box...")
            pyautogui.click(self.chat_input_position.x, self.chat_input_position.y)
            time.sleep(1)

            logging.info("AI Response: Entering chat text...")
            self.status_label.setText("Entering chat text...")
            pyautogui.typewrite(self.response)
            time.sleep(1)

            logging.info("AI Response: Submitting chat text...")
            self.status_label.setText("Submitting chat text...")
            pyautogui.press('enter')
            time.sleep(1)

        except Exception as e:
            self.error = str(e)
            logging.error(f"AI Response Error: {self.error}")
            self.status_label.setText(f"Error: {self.error}")
            time.sleep(3)

        finally:
            logging.info("AI Response: Process completed")
            self.close()

def handle_ollama_response(parent, ollama_api, system_prompt, user_prompt, user_message, chat_input_position):
    try:
        logging.info("Sending request to Ollama API...")
        response = ollama_api.send_request(system_prompt, user_prompt, user_message)
        
        if response is None:
            logging.warning("Ollama API returned None response")
            return None, "Ollama API returned None response"
        
        logging.info("Ollama API response received")
        return response, None
    except Exception as e:
        logging.error(f"Error in Ollama handler: {str(e)}")
        return None, str(e)

settings.py:
from PyQt5.QtWidgets import (QDialog, QVBoxLayout, QFormLayout, QLineEdit, QPushButton, 
                             QLabel, QSpinBox, QTextEdit, QMessageBox, QHBoxLayout)
from PyQt5.QtCore import Qt, QThread, pyqtSignal
from utils import load_settings, save_settings
from ollama import OllamaAPI

class TestOllamaThread(QThread):
    test_complete = pyqtSignal(bool, str)

    def __init__(self, url, model):
        super().__init__()
        self.url = url
        self.model = model

    def run(self):
        try:
            ollama_api = OllamaAPI(self.url, self.model)
            response = ollama_api.send_request("Test prompt", "This is a test message.", "Hello, Ollama!")
            self.test_complete.emit(True, response)
        except Exception as e:
            self.test_complete.emit(False, str(e))

class SettingsDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Settings")
        self.setModal(True)
        self.initUI()
        self.load_current_settings()

    def initUI(self):
        layout = QVBoxLayout(self)

        form_layout = QFormLayout()

        self.ollama_url_input = QLineEdit(self)
        form_layout.addRow("Ollama URL:", self.ollama_url_input)

        self.model_input = QLineEdit(self)
        form_layout.addRow("Model:", self.model_input)

        test_layout = QHBoxLayout()
        self.test_ollama_button = QPushButton("Test Ollama", self)
        self.test_ollama_button.clicked.connect(self.test_ollama)
        test_layout.addWidget(self.test_ollama_button)
        form_layout.addRow("", test_layout)

        self.capture_interval_input = QSpinBox(self)
        self.capture_interval_input.setRange(1, 3600)
        form_layout.addRow("Capture Interval (seconds):", self.capture_interval_input)

        self.my_username_input = QLineEdit(self)
        form_layout.addRow("My Username:", self.my_username_input)

        self.other_usernames_input = QLineEdit(self)
        form_layout.addRow("Other Usernames (comma-separated):", self.other_usernames_input)

        self.prompt_input = QTextEdit(self)
        self.prompt_input.setFixedHeight(100)
        form_layout.addRow("Prompt:", self.prompt_input)

        self.ignored_lines_input = QTextEdit(self)
        self.ignored_lines_input.setFixedHeight(100)
        form_layout.addRow("Ignored Lines Format (one per line):", self.ignored_lines_input)

        layout.addLayout(form_layout)

        save_button = QPushButton("Save", self)
        save_button.clicked.connect(self.save_settings)
        layout.addWidget(save_button)

    def load_current_settings(self):
        settings = load_settings()
        self.ollama_url_input.setText(settings['ollama_url'])
        self.model_input.setText(settings['model'])
        self.capture_interval_input.setValue(settings['capture_interval'])
        self.my_username_input.setText(settings['my_username'])
        self.other_usernames_input.setText(", ".join(settings['other_usernames']))
        self.prompt_input.setPlainText(settings['prompt'])
        self.ignored_lines_input.setPlainText("\n".join(settings.get('ignored_lines', [])))

    def save_settings(self):
        new_settings = {
            'ollama_url': self.ollama_url_input.text(),
            'model': self.model_input.text(),
            'capture_interval': self.capture_interval_input.value(),
            'my_username': self.my_username_input.text(),
            'other_usernames': [username.strip() for username in self.other_usernames_input.text().split(',') if username.strip()],
            'prompt': self.prompt_input.toPlainText(),
            'ignored_lines': [line.strip() for line in self.ignored_lines_input.toPlainText().split('\n') if line.strip()]
        }
        save_settings(new_settings)
        self.accept()

    def test_ollama(self):
        url = self.ollama_url_input.text()
        model = self.model_input.text()
        self.test_thread = TestOllamaThread(url, model)
        self.test_thread.test_complete.connect(self.on_test_complete)
        self.test_thread.start()
        QMessageBox.information(self, "Testing Ollama", "Testing connection to Ollama. Please wait...")

    def on_test_complete(self, success, message):
        if success:
            QMessageBox.information(self, "Test Successful", f"Successfully connected to Ollama.\nResponse: {message}")
        else:
            QMessageBox.critical(self, "Test Failed", f"Failed to connect to Ollama.\nError: {message}")

ui.py:
import logging
import time
from PyQt5.QtWidgets import (QMainWindow, QVBoxLayout, QWidget, QHBoxLayout, 
                             QPushButton, QLabel, QLineEdit, QMessageBox, 
                             QTextEdit, QApplication)
from PyQt5.QtCore import Qt, QTimer, pyqtSlot, QSettings
from utils import load_settings, save_settings, create_new_log_file, setup_logging, append_to_csv
from ollama import OllamaAPI
from settings import SettingsDialog
from analyzer import TransparentWindow
from capture_handler import CaptureHandler
from ai_handler import AIHandler
from chat_position_handler import ChatPositionHandler

class PipsChatAnalyserUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.is_analyzing = False
        self.log_file = None
        self.ollama_api = None
        self.ai_handler = None
        self.capture_interval = 30  # seconds
        self.prompt_text = ""
        self.my_username = ""
        self.other_usernames = []
        self.ignored_patterns = []
        self.chat_position_handler = ChatPositionHandler()
        self.capture_timer = QTimer(self)
        self.capture_timer.timeout.connect(self.perform_capture)
        self.waiting_for_ollama = False
        self.initUI()
        self.setup_logging()
        self.load_settings()
        self.init_analyzer()
        self.init_capture_handler()
        self.init_ai_handler()

    def initUI(self):
        self.setWindowTitle("PIPS CHAT ANALYSER")
        self.setGeometry(100, 100, 800, 600)
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)
        
        # Background Prompt
        layout.addWidget(QLabel("Background Prompt"))
        self.background_prompt = QTextEdit(self)
        self.background_prompt.setPlainText(self.prompt_text)
        self.background_prompt.setFixedHeight(4 * self.background_prompt.fontMetrics().lineSpacing())
        layout.addWidget(self.background_prompt)

        # Save and Settings buttons
        button_layout = QHBoxLayout()
        self.save_button = QPushButton("Save", self)
        self.save_button.clicked.connect(self.save_settings)
        button_layout.addWidget(self.save_button)
        
        self.settings_button = QPushButton("Settings", self)
        self.settings_button.clicked.connect(self.open_settings)
        button_layout.addWidget(self.settings_button)
        layout.addLayout(button_layout)
        
        # Username inputs
        username_layout = QHBoxLayout()
        self.my_username_input = QLineEdit(self)
        self.my_username_input.setPlaceholderText("My username")
        username_layout.addWidget(QLabel("My Username:"))
        username_layout.addWidget(self.my_username_input)
        
        self.other_usernames_input = QLineEdit(self)
        self.other_usernames_input.setPlaceholderText("Other usernames (comma-separated)")
        username_layout.addWidget(QLabel("Other Usernames:"))
        username_layout.addWidget(self.other_usernames_input)
        layout.addLayout(username_layout)
        
        # Chat log
        layout.addWidget(QLabel("Chat log and information"))
        self.chat_log = QTextEdit(self)
        self.chat_log.setReadOnly(True)
        layout.addWidget(self.chat_log)

        # Last captured line display
        self.last_captured_line = QLineEdit(self)
        self.last_captured_line.setReadOnly(True)
        layout.addWidget(QLabel("Last Captured Line:"))
        layout.addWidget(self.last_captured_line)

        # Chat Input Position
        chat_position_layout = QHBoxLayout()
        self.chat_x_input = QLineEdit(self)
        self.chat_y_input = QLineEdit(self)
        self.set_chat_position_button = QPushButton("Set Chat Position", self)
        self.set_chat_position_button.clicked.connect(self.chat_position_handler.set_chat_position)
        chat_position_layout.addWidget(QLabel("Chat X:"))
        chat_position_layout.addWidget(self.chat_x_input)
        chat_position_layout.addWidget(QLabel("Chat Y:"))
        chat_position_layout.addWidget(self.chat_y_input)
        chat_position_layout.addWidget(self.set_chat_position_button)
        layout.addLayout(chat_position_layout)

        # Capture, Start, and Stop buttons
        button_layout = QHBoxLayout()
        self.capture_button = QPushButton("Capture", self)
        self.capture_button.clicked.connect(self.capture_analysis)
        button_layout.addWidget(self.capture_button)
        
        self.start_button = QPushButton("Start", self)
        self.start_button.clicked.connect(self.start_analysis)
        button_layout.addWidget(self.start_button)

        self.stop_button = QPushButton("Stop", self)
        self.stop_button.clicked.connect(self.stop_analysis)
        self.stop_button.setEnabled(False)
        button_layout.addWidget(self.stop_button)

        layout.addLayout(button_layout)

        # Connect the position_set signal
        self.chat_position_handler.position_set.connect(self.update_chat_position_inputs)

    def setup_logging(self):
        self.logger = setup_logging(self.chat_log)

    def load_settings(self):
        settings = load_settings()
        self.ollama_api = OllamaAPI(settings['ollama_url'], settings['model'])
        self.capture_interval = settings['capture_interval']
        self.prompt_text = settings.get('prompt', '')
        self.my_username = settings.get('my_username', '')
        self.other_usernames = settings.get('other_usernames', [])
        self.ignored_patterns = settings.get('ignored_lines', [])
        chat_input_position = settings.get('chat_input_position', {})
        if chat_input_position:
            self.chat_position_handler.set_chat_position_from_settings(chat_input_position['x'], chat_input_position['y'])
            self.update_chat_position_inputs(chat_input_position['x'], chat_input_position['y'])
        
        self.background_prompt.setPlainText(self.prompt_text)
        self.my_username_input.setText(self.my_username)
        self.other_usernames_input.setText(", ".join(self.other_usernames))
        
        if self.ai_handler:
            self.ai_handler.set_background_prompt(self.prompt_text)
        
        logging.info(f"Loaded prompt: {self.prompt_text}")
        logging.info(f"Loaded my username: {self.my_username}")
        logging.info(f"Loaded other usernames: {self.other_usernames}")
        logging.info(f"Loaded ignored patterns: {self.ignored_patterns}")
        logging.info(f"Loaded chat input position: {self.chat_position_handler.get_chat_position()}")
        logging.info(f"Loaded capture interval: {self.capture_interval} seconds")

    def save_settings(self):
        settings = {
            'prompt': self.background_prompt.toPlainText(),
            'my_username': self.my_username_input.text(),
            'other_usernames': [username.strip() for username in self.other_usernames_input.text().split(',') if username.strip()],
            'ollama_url': self.ollama_api.base_url,
            'model': self.ollama_api.model,
            'capture_interval': self.capture_interval,
            'ignored_lines': self.ignored_patterns,
            'chat_input_position': {'x': int(self.chat_x_input.text()), 'y': int(self.chat_y_input.text())} if self.chat_position_handler.has_position() else {}
        }
        save_settings(settings)
        self.load_settings()  # Reload settings after saving
        QMessageBox.information(self, "Success", "Settings saved successfully.")

    def open_settings(self):
        settings_dialog = SettingsDialog(self)
        if settings_dialog.exec_():
            self.load_settings()

    def init_analyzer(self):
        self.analyzer_window = TransparentWindow()
        self.analyzer_window.show()

    def init_capture_handler(self):
        self.capture_handler = CaptureHandler(self.analyzer_window, self.my_username, self.other_usernames, self.ignored_patterns)
        self.capture_handler.capture_complete.connect(self.on_capture_complete)
        self.capture_handler.new_message_detected.connect(self.on_new_message_detected)

    def init_ai_handler(self):
        self.ai_handler = AIHandler(self.ollama_api, self.prompt_text)
        self.ai_handler.response_ready.connect(self.handle_ai_response)

    def capture_analysis(self):
        try:
            self.capture_button.setEnabled(False)
            self.log_file = create_new_log_file()
            logging.info(f"New CSV file created: {self.log_file}")
            self.capture_handler.set_log_file(self.log_file)
            self.capture_handler.reset_capture_state()  # Reset the capture state
            self.capture_handler.start_capture()
        except Exception as e:
            logging.error(f"Error during capture: {str(e)}")
            QMessageBox.critical(self, "Error", f"An error occurred during capture: {str(e)}")
            self.capture_button.setEnabled(True)

    def start_analysis(self):
        if not self.log_file:
            logging.error("Error: No capture performed. Please capture first.")
            QMessageBox.warning(self, "Error", "No capture performed. Please capture first.")
            return
        
        # Check if all settings are not empty
        if not self.check_settings():
            return

        self.is_analyzing = True
        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)
        logging.info("System: Analysis started")

        if not self.chat_position_handler.has_position():
            QMessageBox.information(self, "Chat Input Position", "Please set the chat input position first.")
            return

        self.capture_timer.start(self.capture_interval * 1000)
        logging.info(f"System will start a scan in {self.capture_interval} seconds for new Text")

    def check_settings(self):
        settings = load_settings()
        empty_settings = [key for key, value in settings.items() if not value]
        if empty_settings:
            QMessageBox.warning(self, "Empty Settings", f"The following settings are empty: {', '.join(empty_settings)}")
            return False
        return True

    def stop_analysis(self):
        self.is_analyzing = False
        self.capture_timer.stop()
        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)
        logging.info("System: Analysis stopped")

    def perform_capture(self):
        if not self.is_analyzing or self.waiting_for_ollama:
            return

        logging.info(f"{self.capture_interval} sec before next screen refresh")
        self.capture_handler.start_capture()

    @pyqtSlot(list)
    def on_capture_complete(self, processed_lines):
        if processed_lines:
            self.last_captured_line.setText(processed_lines[-1][1])
            logging.info("Captured text added to CSV")
            for username, message in processed_lines:
                append_to_csv(self.log_file, "captured_conversation", username, message)
        else:
            logging.info("No text captured")

        self.capture_button.setEnabled(True)
        self.start_button.setEnabled(True)
        logging.info("Capture completed, start button enabled")

    @pyqtSlot(str, str)
    def on_new_message_detected(self, username, message):
        self.ai_handler.process_new_message(self.log_file, username, message, self.chat_position_handler.get_chat_position())

    @pyqtSlot(str, str)
    def handle_ai_response(self, response, error):
        self.waiting_for_ollama = False
        if error:
            QMessageBox.warning(self, "Error", f"An error occurred while processing the AI response: {error}")
        else:
            self.chat_position_handler.type_message(response)
            append_to_csv(self.log_file, "ollama_response", "Ollama", response)
            logging.info(f"Reply sent to {self.other_usernames}")

        if self.is_analyzing:
            self.capture_timer.start(self.capture_interval * 1000)

    @pyqtSlot(int, int)
    def update_chat_position_inputs(self, x, y):
        self.chat_x_input.setText(str(x))
        self.chat_y_input.setText(str(y))

if __name__ == "__main__":
    app = QApplication([])
    main_window = PipsChatAnalyserUI()
    main_window.show()
    app.exec_()

utils.py:
import json
import os
import csv
import logging
import re
from PyQt5.QtCore import QSettings, QObject, pyqtSignal
from datetime import datetime

def load_settings():
    settings = QSettings("PipsChat", "ChatAnalyzer")
    try:
        with open('settings.json', 'r') as f:
            file_settings = json.load(f)
    except FileNotFoundError:
        file_settings = {}
    
    return {
        'ollama_url': file_settings.get('ollama_url') or settings.value("ollama_url", "http://localhost:11434"),
        'model': file_settings.get('model') or settings.value("model", "llama2"),
        'capture_interval': int(file_settings.get('capture_interval') or settings.value("capture_interval", 15)),
        'prompt': file_settings.get('prompt') or settings.value("prompt", ""),
        'my_username': file_settings.get('my_username') or settings.value("my_username", ""),
        'other_usernames': file_settings.get('other_usernames') or settings.value("other_usernames", []),
        'ignored_lines': file_settings.get('ignored_lines') or settings.value("ignored_lines", []),
        'chat_input_position': file_settings.get('chat_input_position') or settings.value("chat_input_position", {})
    }

def save_settings(settings):
    q_settings = QSettings("PipsChat", "ChatAnalyzer")
    for key, value in settings.items():
        q_settings.setValue(key, value)
    
    with open('settings.json', 'w') as f:
        json.dump(settings, f, indent=4)

def create_new_log_file():
    log_folder = './logs'
    if not os.path.exists(log_folder):
        os.makedirs(log_folder)

    i = 1
    while os.path.exists(f"{log_folder}/chatlog{i:04d}.csv"):
        i += 1
    
    log_file = f"{log_folder}/chatlog{i:04d}.csv"
    
    with open(log_file, mode='w', newline='', encoding='utf-8') as file:
        writer = csv.writer(file)
        writer.writerow(["ID", "Conversation", "Username", "Message"])
    
    return log_file

def append_to_csv(log_file, conversation_type, username, message):
    with open(log_file, mode='a', newline='', encoding='utf-8') as file:
        writer = csv.writer(file)
        
        with open(log_file, mode='r', newline='', encoding='utf-8') as readfile:
            lines = list(csv.reader(readfile))
            last_id = int(lines[-1][0]) if len(lines) > 1 else 0
        
        writer.writerow([f"{last_id + 1:04d}", conversation_type, username, message])

def get_last_messages(log_file, n=10):
    try:
        with open(log_file, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.reader(file)
            next(reader)  # Skip header
            messages = list(reader)
            return [(row[2], row[3]) for row in messages[-n:]]
    except Exception as e:
        logging.error(f"Error reading last messages from CSV: {str(e)}")
        return []

class QTextEditLogger(logging.Handler, QObject):
    log_message = pyqtSignal(str)

    def __init__(self, widget):
        super().__init__()
        QObject.__init__(self)
        self.widget = widget
        self.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

    def emit(self, record):
        msg = self.format(record)
        self.log_message.emit(msg)

def setup_logging(log_widget):
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    # File handler
    file_handler = logging.FileHandler('application_log.txt')
    file_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
    logger.addHandler(file_handler)
    
    # Widget handler
    widget_handler = QTextEditLogger(log_widget)
    widget_handler.log_message.connect(log_widget.append)
    logger.addHandler(widget_handler)

    return logger

def is_ignored_line(line, ignored_patterns):
    # Check if the line matches any of the ignored patterns
    for pattern in ignored_patterns:
        if re.search(pattern, line):
            return True
    
    # Check for date formats
    date_patterns = [
        r"\w+,\s+\w+\s+\d{1,2}(st|nd|rd|th)\s+v",  # e.g., "Friday, September 13th v"
        r"Today\s+v",
        r"\w+\s+\d{1,2}(st|nd|rd|th),\s+\d{4}"  # e.g., "September 16th, 2024"
    ]
    
    for pattern in date_patterns:
        if re.search(pattern, line):
            return True
    
    return False

def process_captured_text(text, my_username, other_usernames, ignored_patterns):
    logging.debug(f"Processing captured text: {text[:100]}...")  # Log first 100 characters
    lines = text.split('\n')
    processed_lines = []
    current_username = None

    for line in lines:
        line = line.strip()
        if not line or is_ignored_line(line, ignored_patterns):
            continue

        for username in [my_username] + other_usernames:
            if line.lower().startswith(username.lower()):
                current_username = username
                message = line[len(username):].strip()
                if message.startswith(':'):
                    message = message[1:].strip()
                processed_lines.append((current_username, message))
                break
        else:
            if current_username:
                processed_lines.append((current_username, line))

    logging.debug(f"Processed {len(processed_lines)} lines")
    return processed_lines

